import { existsSync, readFileSync, readdirSync, writeFileSync, mkdirSync } from "fs";
import { join, dirname } from "path";
import chalk from "chalk";

/**
 * Template System for DataChonk CLI
 * 
 * Allows teams to customize dbt code patterns via configurable Jinja templates.
 * Templates can be stored locally or fetched from a remote registry.
 */

export interface TemplateVariable {
  name: string;
  type: "string" | "boolean" | "array" | "object";
  required: boolean;
  default?: unknown;
  description?: string;
}

export interface Template {
  name: string;
  version: string;
  description: string;
  category: "staging" | "intermediate" | "mart" | "snapshot" | "source" | "test" | "macro" | "custom";
  variables: TemplateVariable[];
  content: string;
  author?: string;
  tags?: string[];
}

export interface TemplateRegistry {
  templates: Map<string, Template>;
  customDir: string;
  builtInDir: string;
}

// Template locations
const TEMPLATE_DIRS = {
  builtIn: join(dirname(new URL(import.meta.url).pathname), "..", "templates"),
  project: join(process.cwd(), ".datachonk", "templates"),
  user: join(process.env.HOME || "~", ".datachonk", "templates"),
};

// Built-in templates
const BUILT_IN_TEMPLATES: Template[] = [
  // Staging model template
  {
    name: "staging-model",
    version: "1.0.0",
    description: "Standard staging model that cleans and renames source columns",
    category: "staging",
    variables: [
      { name: "source_name", type: "string", required: true, description: "Name of the source" },
      { name: "source_table", type: "string", required: true, description: "Source table name" },
      { name: "columns", type: "array", required: false, description: "Columns to select" },
      { name: "rename_columns", type: "object", required: false, description: "Column rename mapping" },
      { name: "add_metadata", type: "boolean", required: false, default: true, description: "Add metadata columns" },
    ],
    content: `{{/*
  Staging Model Template
  Generated by DataChonk
*/}}

with source as (
    select * from {{ source('{{ source_name }}', '{{ source_table }}') }}
),

renamed as (
    select
        {%- if columns %}
        {%- for col in columns %}
        {%- if rename_columns and col in rename_columns %}
        {{ col }} as {{ rename_columns[col] }}{% if not loop.last %},{% endif %}
        {%- else %}
        {{ col }}{% if not loop.last %},{% endif %}
        {%- endif %}
        {%- endfor %}
        {%- else %}
        -- TODO: Add column selections
        *
        {%- endif %}
        
        {%- if add_metadata %}
        -- Metadata columns
        , _loaded_at
        , _source_file
        {%- endif %}
    from source
)

select * from renamed
`,
  },
  
  // Dimension model template
  {
    name: "dimension-model",
    version: "1.0.0",
    description: "Dimension table following Kimball methodology",
    category: "mart",
    variables: [
      { name: "entity_name", type: "string", required: true, description: "Name of the entity" },
      { name: "primary_key", type: "string", required: true, description: "Primary key column" },
      { name: "source_model", type: "string", required: true, description: "Source staging model" },
      { name: "scd_type", type: "string", required: false, default: "1", description: "SCD type (1 or 2)" },
      { name: "business_keys", type: "array", required: false, description: "Business key columns" },
    ],
    content: `{{/*
  Dimension Model Template - {{ entity_name }}
  SCD Type: {{ scd_type | default: '1' }}
  Generated by DataChonk
*/}}

{{ config(
    materialized='table',
    unique_key='{{ primary_key }}'
) }}

with source_data as (
    select * from {{ ref('{{ source_model }}') }}
),

{%- if scd_type == '2' %}
-- SCD Type 2: Track historical changes
with_row_hash as (
    select
        *,
        {{ dbt_utils.generate_surrogate_key(business_keys) }} as row_hash
    from source_data
),

final as (
    select
        {{ dbt_utils.generate_surrogate_key([primary_key]) }} as {{ primary_key }}_sk,
        *,
        current_timestamp as valid_from,
        null::timestamp as valid_to,
        true as is_current
    from with_row_hash
)
{%- else %}
-- SCD Type 1: Overwrite changes
final as (
    select
        {{ dbt_utils.generate_surrogate_key(['{{ primary_key }}']) }} as {{ primary_key }}_sk,
        *,
        current_timestamp as updated_at
    from source_data
)
{%- endif %}

select * from final
`,
  },

  // Fact model template
  {
    name: "fact-model",
    version: "1.0.0",
    description: "Fact table following Kimball methodology",
    category: "mart",
    variables: [
      { name: "fact_name", type: "string", required: true, description: "Name of the fact" },
      { name: "grain", type: "string", required: true, description: "Description of the grain" },
      { name: "source_model", type: "string", required: true, description: "Source staging model" },
      { name: "dimension_refs", type: "array", required: false, description: "Dimension foreign keys" },
      { name: "measures", type: "array", required: false, description: "Measure columns" },
    ],
    content: `{{/*
  Fact Model Template - {{ fact_name }}
  Grain: {{ grain }}
  Generated by DataChonk
*/}}

{{ config(
    materialized='incremental',
    unique_key='event_id',
    incremental_strategy='merge'
) }}

with source_data as (
    select * from {{ ref('{{ source_model }}') }}
    {% if is_incremental() %}
    where _loaded_at > (select max(_loaded_at) from {{ this }})
    {% endif %}
),

{%- if dimension_refs %}
-- Join dimension keys
with_dimensions as (
    select
        src.*
        {%- for dim in dimension_refs %}
        , {{ dim.dimension }}.{{ dim.key }}_sk as {{ dim.key }}_fk
        {%- endfor %}
    from source_data src
    {%- for dim in dimension_refs %}
    left join {{ ref(dim.dimension) }} as {{ dim.dimension }}
        on src.{{ dim.join_key }} = {{ dim.dimension }}.{{ dim.key }}
    {%- endfor %}
),
{%- endif %}

final as (
    select
        {{ dbt_utils.generate_surrogate_key(['event_id']) }} as fact_{{ fact_name }}_sk,
        
        -- Dimension foreign keys
        {%- if dimension_refs %}
        {%- for dim in dimension_refs %}
        {{ dim.key }}_fk,
        {%- endfor %}
        {%- endif %}
        
        -- Degenerate dimensions / attributes
        event_timestamp,
        
        -- Measures
        {%- if measures %}
        {%- for measure in measures %}
        {{ measure }}{% if not loop.last %},{% endif %}
        {%- endfor %}
        {%- else %}
        -- TODO: Add measure columns
        1 as count_events
        {%- endif %}
        
    from {% if dimension_refs %}with_dimensions{% else %}source_data{% endif %}
)

select * from final
`,
  },

  // Test template
  {
    name: "generic-test",
    version: "1.0.0",
    description: "Generic data quality test",
    category: "test",
    variables: [
      { name: "test_name", type: "string", required: true, description: "Name of the test" },
      { name: "model", type: "string", required: true, description: "Model to test" },
      { name: "column", type: "string", required: false, description: "Column to test" },
      { name: "condition", type: "string", required: true, description: "Test condition" },
      { name: "severity", type: "string", required: false, default: "error", description: "Test severity" },
    ],
    content: `{{/*
  Custom Test: {{ test_name }}
  Generated by DataChonk
*/}}

{{ config(severity='{{ severity | default: "error" }}') }}

with validation as (
    select
        {%- if column %}
        {{ column }},
        {%- endif %}
        *
    from {{ ref('{{ model }}') }}
    where not ({{ condition }})
)

select * from validation
`,
  },

  // Snapshot template
  {
    name: "snapshot-template",
    version: "1.0.0",
    description: "dbt snapshot for tracking changes over time",
    category: "snapshot",
    variables: [
      { name: "snapshot_name", type: "string", required: true, description: "Snapshot name" },
      { name: "source_model", type: "string", required: true, description: "Source model or table" },
      { name: "unique_key", type: "string", required: true, description: "Unique key column" },
      { name: "strategy", type: "string", required: false, default: "timestamp", description: "Snapshot strategy" },
      { name: "updated_at", type: "string", required: false, default: "updated_at", description: "Updated at column" },
    ],
    content: `{{/*
  Snapshot: {{ snapshot_name }}
  Strategy: {{ strategy | default: 'timestamp' }}
  Generated by DataChonk
*/}}

{% snapshot {{ snapshot_name }} %}

{{ config(
    target_schema='snapshots',
    unique_key='{{ unique_key }}',
    strategy='{{ strategy | default: "timestamp" }}',
    {%- if strategy == 'check' %}
    check_cols='all',
    {%- else %}
    updated_at='{{ updated_at | default: "updated_at" }}',
    {%- endif %}
    invalidate_hard_deletes=True
) }}

select * from {{ ref('{{ source_model }}') }}

{% endsnapshot %}
`,
  },
];

// Template registry instance
let registry: TemplateRegistry | null = null;

/**
 * Initialize the template registry
 */
export function initTemplates(): TemplateRegistry {
  if (registry) return registry;

  registry = {
    templates: new Map(),
    customDir: TEMPLATE_DIRS.project,
    builtInDir: TEMPLATE_DIRS.builtIn,
  };

  // Load built-in templates
  for (const template of BUILT_IN_TEMPLATES) {
    registry.templates.set(template.name, template);
  }

  // Load custom templates from project directory
  loadCustomTemplates(TEMPLATE_DIRS.project);
  loadCustomTemplates(TEMPLATE_DIRS.user);

  return registry;
}

/**
 * Load custom templates from a directory
 */
function loadCustomTemplates(dir: string): void {
  if (!existsSync(dir)) return;

  const files = readdirSync(dir).filter((f) => f.endsWith(".json"));
  
  for (const file of files) {
    try {
      const content = readFileSync(join(dir, file), "utf-8");
      const template = JSON.parse(content) as Template;
      
      if (isValidTemplate(template)) {
        registry?.templates.set(template.name, template);
        console.log(chalk.gray(`Loaded template: ${template.name}`));
      }
    } catch {
      console.warn(chalk.yellow(`Failed to load template: ${file}`));
    }
  }
}

/**
 * Validate template structure
 */
function isValidTemplate(obj: unknown): obj is Template {
  if (!obj || typeof obj !== "object") return false;
  const t = obj as Record<string, unknown>;
  return (
    typeof t.name === "string" &&
    typeof t.version === "string" &&
    typeof t.content === "string" &&
    typeof t.category === "string"
  );
}

/**
 * Get a template by name
 */
export function getTemplate(name: string): Template | null {
  if (!registry) initTemplates();
  return registry?.templates.get(name) || null;
}

/**
 * List all available templates
 */
export function listTemplates(category?: string): Template[] {
  if (!registry) initTemplates();
  
  const templates = Array.from(registry?.templates.values() || []);
  
  if (category) {
    return templates.filter((t) => t.category === category);
  }
  
  return templates;
}

/**
 * Render a template with variables
 */
export function renderTemplate(
  templateName: string,
  variables: Record<string, unknown>
): string {
  const template = getTemplate(templateName);
  if (!template) {
    throw new Error(`Template not found: ${templateName}`);
  }

  // Simple variable substitution (for Jinja-like syntax)
  let content = template.content;

  // Replace {{ variable }} patterns
  content = content.replace(/\{\{\s*(\w+)(?:\s*\|\s*default:\s*['"]([^'"]+)['"])?\s*\}\}/g, 
    (match, varName, defaultValue) => {
      const value = variables[varName];
      if (value !== undefined) {
        return String(value);
      }
      if (defaultValue !== undefined) {
        return defaultValue;
      }
      // Check template variable defaults
      const varDef = template.variables.find((v) => v.name === varName);
      if (varDef?.default !== undefined) {
        return String(varDef.default);
      }
      return match; // Keep original if no value
    }
  );

  // Handle conditionals: {%- if condition %}...{%- endif %}
  content = content.replace(
    /\{%-?\s*if\s+(\w+)\s*%\}([\s\S]*?)\{%-?\s*endif\s*%\}/g,
    (match, condition, body) => {
      const value = variables[condition];
      if (value && (Array.isArray(value) ? value.length > 0 : Boolean(value))) {
        return body;
      }
      return "";
    }
  );

  // Handle loops: {%- for item in array %}...{%- endfor %}
  content = content.replace(
    /\{%-?\s*for\s+(\w+)\s+in\s+(\w+)\s*%\}([\s\S]*?)\{%-?\s*endfor\s*%\}/g,
    (match, itemName, arrayName, body) => {
      const array = variables[arrayName];
      if (!Array.isArray(array)) return "";
      
      return array
        .map((item, index) => {
          let itemBody = body;
          // Replace item references
          if (typeof item === "string") {
            itemBody = itemBody.replace(new RegExp(`\\{\\{\\s*${itemName}\\s*\\}\\}`, "g"), item);
          } else if (typeof item === "object" && item !== null) {
            for (const [key, val] of Object.entries(item)) {
              itemBody = itemBody.replace(
                new RegExp(`\\{\\{\\s*${itemName}\\.${key}\\s*\\}\\}`, "g"),
                String(val)
              );
            }
          }
          // Replace loop variables
          itemBody = itemBody.replace(/\{\{\s*loop\.index\s*\}\}/g, String(index + 1));
          itemBody = itemBody.replace(/\{\{\s*loop\.last\s*\}\}/g, String(index === array.length - 1));
          return itemBody;
        })
        .join("");
    }
  );

  return content;
}

/**
 * Save a custom template
 */
export function saveTemplate(template: Template, location: "project" | "user" = "project"): void {
  const dir = location === "project" ? TEMPLATE_DIRS.project : TEMPLATE_DIRS.user;
  
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  const path = join(dir, `${template.name}.json`);
  writeFileSync(path, JSON.stringify(template, null, 2));
  
  // Update registry
  if (registry) {
    registry.templates.set(template.name, template);
  }
  
  console.log(chalk.green(`Template saved: ${path}`));
}

/**
 * Delete a custom template
 */
export function deleteTemplate(name: string): boolean {
  for (const dir of [TEMPLATE_DIRS.project, TEMPLATE_DIRS.user]) {
    const path = join(dir, `${name}.json`);
    if (existsSync(path)) {
      unlinkSync(path);
      registry?.templates.delete(name);
      return true;
    }
  }
  return false;
}

/**
 * Print available templates
 */
export function printTemplates(): void {
  if (!registry) initTemplates();
  
  const templates = listTemplates();
  const categories = [...new Set(templates.map((t) => t.category))];
  
  console.log(chalk.bold("\nAvailable Templates"));
  console.log(chalk.gray("â”€".repeat(50)));
  
  for (const category of categories) {
    console.log(chalk.bold(`\n${category.charAt(0).toUpperCase() + category.slice(1)}:`));
    const categoryTemplates = templates.filter((t) => t.category === category);
    
    for (const template of categoryTemplates) {
      console.log(`  ${chalk.cyan(template.name)} - ${template.description}`);
    }
  }
}

// Helper to delete files (need to import)
function unlinkSync(path: string): void {
  const fs = require("fs");
  fs.unlinkSync(path);
}
